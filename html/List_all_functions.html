
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Complete list of all atom functions</title><meta name="generator" content="MATLAB 9.10"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2022-04-05"><meta name="DC.source" content="List_all_functions.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Complete list of all atom functions</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Version</a></li><li><a href="#2">Contact</a></li><li><a href="#3">All functions</a></li><li><a href="#4">Version</a></li><li><a href="#5">Contact</a></li></ul></div><h2 id="1">Version</h2><p>2.11</p><h2 id="2">Contact</h2><p>Please report problems/bugs to <a href="mailto:michael.holmboe@umu.se">michael.holmboe@umu.se</a></p><h2 id="3">All functions</h2><div><ol><li><a href="add2atom.html">add2atom(XYZ_labels,XYZ_data,varargin)</a> %&nbsp;This function appends so-called XYZ atomtype labels and XYZ data to an existing atom struct</li><li><a href="analyze_atom.html">analyze_atom(atom,Box_dim)</a> % This function fetches various preperties of the atoms in the atom struct, using for instance the bond valence method and for instance the radii originally taken from below	Revised effective ionic radii and systematic studies of interatomic distances in halides and chalcogenides. R. D. Shannon Acta Cryst. (1976) A32, 751-767.</li><li><a href="atom2make_ndx_bonded.html">atom2make_ndx_bonded(filename,groupname,atomtypes)</a> % This function can help you print one custom gromacs .ndx group,based on the atomtypes names.</li><li><a href="atom2make_ndx.html">atom2make_ndx(filename,groupname,atomtypes,molid)</a> % This little script can be used to write custom made Gromacs index files</li><li><a href="atom2mk_angndx">atom2mk_angndx(filename,groupname,atomtypes)</a> % This function can help you print one custom gromacs angle.ndx group, based on the atomtypes names</li><li><a href="atomic_scattering_factors.html">atomic_scattering_factors(Atom_label,lambda,twotheta,DW)</a> % This function retrieves the atomic scattering factor vs 2theta using the 11 coeff parameters from Waasmaier Kirfel, 1995</li><li><a href="ave_atom.html">ave_atom(atom)</a> %&nbsp;This function calculates the mean of the atom coordinates</li><li><a href="bend_atom.html">bend_atom(atom,Box_dim,Radii)</a> %&nbsp;This simple function tries to bend an atom struct</li><li><a href="bond_atom.html">bond_atom(atom,Box_dim,max_long_dist)</a> %&nbsp;This function tries to assign all bonds to a Bond_matrix and a Bond_index variable</li><li><a href="bond_angle_atom.html">bond_angle_atom(atom,Box_dim,max_short_dist,max_long_dist,varargin)</a> %&nbsp;This function tries to find all bonds and angles of the atom struct 'more' is an optional varargin argument</li><li><a href="bond_angle_type.html">bond_angle_type(atom1,atom2,Box_dim,rmin,rmax,angle_limit,varargin)</a> % This tries to find all bonds and angles of the atom types</li><li><a href="bond_angle_dihedral_atom.html">bond_angle_dihedral_atom(atom,Box_dim,varargin)</a> %&nbsp;This function tries to find all bonds, angles and dihedrals of the atom struct. Rmaxshort and Rmaxlong as well as 'more' is an optional varargin argument</li><li><a href="bond_valence_atom.html">bond_valence_atom(atom,Box_dim,varargin)</a> % This function tries to calculate the bond valence values according to the bond valence method</li><li><a href="bond_valence_data.html">bond_valence_data(ion1,ion2,R,varargin)</a> % This function fetches the data and matches it to the passed atom types used to calculate the bond valence values according to <a href="http://www.iucr.org/resources/data/datasets/bond-valence-parameters">http://www.iucr.org/resources/data/datasets/bond-valence-parameters</a></li><li><a href="cat_atom.html">cat_atom.m</a> % This is a special script (and not a function) that imports and appends atom structs into a .gro trajectory file, useful to make a trajectory with varying number of particles</li><li><a href="cell_list_dist_matrix_atom.html">cell_list_dist_matrix_atom(atom,Box_dim,varargin)</a> % This function calculates the distance matrix from the atom struct, using a cell list algorithm adapted from the Matlab MDtoolbox by Yasuhiro Matsunaga</li><li><a href="Box_dim2Cell.html">Box_dim2Cell(Box_dim)</a> % * This function transforms the 1x3 or the 1x9 Box_dim variable to the 1x6 Cell variable</li><li><a href="Cell2Box_dim.html">Cell2Box_dim(Cell)</a> %  This function transforms the 1x6 Cell variable containing the a, b, c cell values and  the alfa, beta, gamma angle values as used in a typical .pdb file, into a 1x3 or the 1x9  Box_dim variable</li><li><a href="center_atom.html">center_atom(atom,Box_dim,resname,dim)</a> %&nbsp;This function centers the atom with respect to the resname molecule</li><li><a href="charge_atom.html">charge_atom(atom,Box_dim,ffname,watermodel,varargin)</a> %&nbsp;This function tries to charge the atom accorind to clayff or interface ff</li><li><a href="charge_clayff_2004_atom.html">charge_clayff_2004_atom(atom,Box_dim,varargin)</a> % Sets the charge for the original Clayff atomtypes for the original Clayff ff from the Cygan et al., 2004 paper</li><li><a href="charge_clayff_atom.html">charge_clayff_atom(atom,Box_dim,varargin)</a> % Sets the charge for Clayff atomtypes&nbsp;</li><li><a href="charge_interface_atom.html">charge_interface_atom(atom,Box_dim,varargin)</a> % Sets the charge for Interface atomtypes&nbsp;</li><li><a href="charge_interface15_atom.html">charge_interface15_atom(atom,Box_dim,varargin)</a> % Sets the charge for Interface 1.5 atomtypes</li><li><a href="charge_opls_go_atom.html">charge_opls_go_atom(atom,Box_dim,varargin)</a> % Sets the charge for some specific OPLS atomtypes</li><li><a href="check_clayff_2004_charge.html">check_clayff_2004_charge(atom)</a> %&nbsp;check_clayff_2004_charge.m - This checks the charge of the original Clayff atomtypes by Mholmboe</li><li><a href="check_clayff_charge.html">check_clayff_charge(atom)</a> %&nbsp;check_clayff_charge.m - This checks the charge of the Clayff atomtypes by Mholmboe</li><li><a href="check_clayff_H2Odens.html">check_clayff_H2Odens(atom,Box_dim)</a> %&nbsp;Check the approx. water density for a clayff system</li><li><a href="check_H2Odens.html">check_H2Odens(atom,Box_dim)</a> % Computes the water density</li><li><a href="check_interface_charge.html">check_interface_charge(atom)</a> %&nbsp; This checks the charge of the INTERFACE atomtypes by Mholmboe</li><li><a href="check_interface15_charge.html">check_interface15_charge(atom)</a> %&nbsp; This checks the charge of the INTERFACE 1.5 atomtypes by Mholmboe</li><li><a href="cn_atom.html">cn_atom(atom,Box_dim)</a> % This function tries to extract the coordination number of all the atom struct indexes and store it in the field [atom.cn].</li><li><a href="clayff_2004_atom.html">clayff_2004_atom(atom,Box_dim,varargin)</a> % Assigns the original Clayff atom types by Cygan et al., 2004. Can also 'heal' edges&nbsp;</li><li><a href="clayff_2004_param.html">clayff_2004_param(Atom_label,varargin)</a> % Holds the ion and the original Clayff atomtype parameters</li><li><a href="clayff_atom.html">clayff_atom(atom,Box_dim,varargin)</a> % Assigns the Clayff atom types by MHolmboe. Can also 'heal' edges&nbsp;</li><li><a href="clayff_param.html">clayff_param(Atom_label,varargin)</a> % Holds the ion and Clayff atomtype parameters</li><li><a href="clayff210_atom.html">clayffmod_atom(atom,Box_dim,varargin)</a> % Assigns the modififed Clayff atom types. Can also 'heal' edges&nbsp;</li><li><a href="clayff211_atom.html">clayffmod_atom(atom,Box_dim,varargin)</a> % New faster version. Assigns the modififed Clayff atom types. Can also 'heal' edges&nbsp;</li><li><a href="closest_atom.html">closest_atom(atom1,atom2,Box_dim)</a> % This function returns the atom1 struct with the nMolId's in atom1 closest to the atom2 struct.</li><li><a href="COM_atom.html">COM_atom(atom,MolID)</a> %&nbsp;This function calculates the COM for certain elements</li><li><a href="COM_func.html">COM_func(MolID,XYZ_data,Atom_label,XYZ_labels,Box_dim)</a> % This calculates the center of mass for water. Slow due to pbc...</li><li><a href="COM_molid.html">COM_molid(atom,MolID)</a> %&nbsp;This function calculates the COM for certain elements</li><li><a href="COM_SOL.html">COM_SOL(MolID,XYZ_data,Atom_label,XYZ_labels,Box_dim)</a> % Computes the COM of SPC water?</li><li><a href="composition_atom.html">composition_atom(atom)</a> %&nbsp;This function looks at the composition of the atom struct</li><li><a href="concatenate_atom.html">concatenate_atom(atom_1,atom_2)</a> %&nbsp;This function concatenats atom sections.</li><li><a href="condense_atom.html">condense_atom(atom,Box_dim,s)</a> %&nbsp;This function tries to minimize the box size and remove gaps between molids?</li><li><a href="CONECT_atom.html">CONECT_atom(atom,Box_dim,short_r,long_r)</a> % This prints conect records for pdb files</li><li><a href="copy_atom.html">copy_atom(atom,atomtype,new_atomtype,new_resname,trans_vec,varargin)</a> % This function copies and translates atoms in the atom struct</li><li><a href="copy_type.html">copy_type(atom,atomtype,new_atomtype,new_resname,trans_vec,varargin)</a> % This function copies and translates types in the atom struct</li><li><a href="create_atom.html">create_atom(type,resname,limits,nmax,varargin)</a> % Creates new atoms, good for adding ions to a system. Creates atoms within a certain region defined by <a href="limits">limits</a></li><li><a href="create_grid_atom.html">create_grid_atom(atom_label,nM,limits,dim,varargin)</a> % This old function puts ions on a grid plane and adds it to an atom struct</li><li><a href="density_atom.html">density_atom(atom,Box_dim)</a> %&nbsp;This function calculates concentration and electron density profiles. If the atom struct contains the field charge. the charge density, electric field and electrostatic potential is also calculated.</li><li><a href="dipoles_atom.html">dipoles_atom(Elements,Box_dim)</a> %&nbsp;This function calculates the dipole vector of water. Similar to the COM_func</li><li><a href="dist_matrix_atom.html">dist_matrix_atom(atom,Box_dim)</a> % This calculates the distance matrix from the atom struct</li><li><a href="draw_box_atom.html">draw_box_atom(Box_dim,LineColor,LineThickness)</a> % Draws a box</li><li><a href="duplicate_atom.html">duplicate_atom(atom,molID)</a> %&nbsp;This function duplicates residue with molid MolID</li><li><a href="element_atom.html">element_atom(atom,varargin)</a>&nbsp; % Converts atomtypes to element types. This function replaces the atomtypes names with the element names</li><li><a href="element_color.html">element_color(Atom_label)</a> % This function assigns a certain color to each element. Estethic improvements are welcome...</li><li><a href="find_bonded_atom.html">find_bonded_atom(atom,bond_matrix,label1,label2)</a> %&nbsp;This function does a cross check of the bond matrix</li><li><a href="find_pair_atom.html">find_pair_atom(atom,bond_matrix,Atom_label1,Atom_label2)</a> % This function does a cross check of the bond matrix</li><li><a href="fit2lattice_atom.html">fit2lattice_atom(atom_model,atom_ref,Box_dim_ref)</a> % This is a special function imports a model structure of a single molecule like PO43- and tries to fit it into a crystal lattice possibly holding multiple such sites.</li><li><a href="frac2atom.html">frac2atom(atom,Box_dim,angleparam,angletype)</a> % This function transforms fractional coordinates to cartesian</li><li><a href="frame2atom.html">frame2atom(atom,traj,frame,Box_dim,varargin)</a> % This function extracts a frame to the trajectory matrix</li><li><a href="fuse_atom.html">fuse_atom(atom,Box_dim,varargin)</a> % This function tries to fuse all sites within a certain cutoff rmax, typically 0.85 &Aring;</li><li><a href="G2_atom.html">G2_atom(atom,Box_dim)</a> % This function calculates the continuous G2 factor from the cos and sin terms and also saves a struct variable for G2_calc_func(). You might wnat to edit the atomtype names below to fit your needs...</li><li><a href="gmx_make_ndx.html">gmx_make_ndx(groupname,ind)</a> %&nbsp;This function helps you print custom gromacs .ndx files</li><li><a href="gmx_mk_angndx.html">gmx_mk_angndx(groupname,ind)</a> %&nbsp;This function helps you print custom gromacs angle .ndx files</li><li><a href="grid2atom.html">grid2atom(atom_label,nM,limits,dim,varargin)</a> %&nbsp; grid2atom.m - This puts particles such as ions on a 2D grid (i.e. a plane)&gt; % and adds it to an atom struct</li><li><a href="heal_atom.html">heal_atom(atom,Box_dim,ind,varargin)</a> % This function heals sites in the atom struct given by the index vector ind, by adding a certain atomtype to a new atom struct called healed_atom. It does so by placing the new atom type opposite to the mean position of all neighbours within rcut [&Aring;] of the healed site.</li><li><a href="hist_atom.html">hist_atom(atom,s)</a> %&nbsp;This function is used to calculate density profiles in the X|Y|Z-direction</li><li><a href="histz_atom.html">histz_atom(atom,s)</a> %&nbsp;This function is used to calculate density profiles in the Z-direction</li><li><a href="import_atom_car.html">import_atom_car(filename,varargin)</a> % This function imports .car files from Hendrik Heinz INTERFACE ff distribution, and then tries to write out a Gromacs molecular topology file (.itp) and a new .pdb file</li><li><a href="import_atom_gro.html">import_atom_gro(filename)</a> %&nbsp;This function imports .gro files into the atom struct</li><li><a href="import_atom_multiple_gro.html">import_atom_multiple_gro(filename,nFrames)</a> %&nbsp;This function import multiple .gro files</li><li><a href="import_atom_pdb.html">import_atom_pdb(filename)</a> %&nbsp;This function imports .pdb files into the atom struct</li><li><a href="import_atom_xyz.html">import_atom_xyz(filename)</a> % This imports an .xyz file into the atom struct</li><li><a href="import_atom.html">import_atom(filename)</a> %&nbsp;import_atom.m - This imports a .xyz/.gro/.pdb file and puts the data in a structure variable called atom</li><li><a href="import_gro_traj.html">import_gro_traj(filename,varargin)</a> %&nbsp;This function imports an strcture and an .gro trajectory file</li><li><a href="import_mc_pdb_traj.html">import_mc_pdb_traj(filename,varargin)</a> %&nbsp;This function imports an structure and an .pdb trajectory file, and can handle changing number of particles</li><li><a href="import_pdb_traj.html">import_pdb_traj(filename,varargin)</a> %&nbsp;This function imports an strcture and an .pdb trajectory file.</li><li><a href="import_traj.html">import_traj(filenameconf,filenametraj)</a> %&nbsp;This function imports an strcture and an dcd, trr, xtc, xyz or gro&nbsp; trajectory file.</li><li><a href="import_trr.html">import_trr(filenameconf,filenametraj)</a> %&nbsp;This function imports an structure and an trr&nbsp; trajectory file</li><li><a href="import_trrv2.html">import_trrv2(filenameconf,filenametraj)</a> %&nbsp;This function imports an structure and an trr&nbsp; trajectory file</li><li><a href="import_xtc.html">import_xtc(filenameconf,filenamextc)</a> %&nbsp;import_atom_xtc.m - This imports a structure file and a xtc file</li><li><a href="import_xtcv2.html">import_xtcv2(filenameconf,filenamextc)</a> %&nbsp;import_atom_xtc.m - This imports a structure file and a xtc file</li><li><a href="import_xvg.html">import_xvg(filename)</a> % This function imports a Gromacs .xvg file</li><li><a href="import_xyz_traj.html">import_xyz_traj(filenametraj)</a> %&nbsp;import_xyz_traj.m - This imports an strcture and an .xyz trajectory file.</li><li><a href="import_xyz.html">import_xyz(filename)</a> % This function imports an .xyz file. Atom types should be made of letters, not numbers... Try the import_atom_xyz function instead...</li><li><a href="insert_atom.html">insert_atom(atom_in,limits,rotate,r,maxsol,solute_atom,varargin)</a> % - This inserts a molecule from a structure file into a region defined by <a href="limits">limits</a> with a atom (molecule)&gt; % structure</li><li><a href="interface_atom.html">interface_atom(atom,Box_dim,varargin)</a> % This function tries to assign all atoms according to the interface atom types (with modified atom names by MHolmboe), with some modifications for edges...</li><li><a href="interface_param.html">interface_param(Atom_label,water_model)</a> %&nbsp; This holds the extended INTERFACE ff parameters</li><li><a href="interface15_atom.html">interface15_atom(atom,Box_dim,varargin)</a> % This function tries to assign all atoms according to the interface1.5 atom types (with modified atom names by MHolmboe), with some modifications for edges...</li><li><a href="interface15_param.html">interface15_param(Atom_label,water_model)</a> %&nbsp; This holds the extended INTERFACE1.5 ff parameters</li><li><a href="ionize_atom.html">ionize_atom(type,resname,limits,nmax,varargin)</a> % This function adds ions within a certain region defined by <a href="limits">limits</a> or close to a surface in an exponential fashion</li><li><a href="keep_atom.html">keep_atom(atom,resname)</a> %&nbsp;keep_atom.m - This removes all but resname</li><li><a href="keep_resname.html">keep_resname(atom,resnames)</a> % keep_resname.m - This removes all but the resnames</li><li><a href="lmp_atom_style_full_func.html">lmp_atom_style_full_func(fid,Atom_label,Charge,XYZ_labels,XYZ_data)</a> %&nbsp;This creates and prints the Atoms section properties in the LAMMPS data file .lj file according to atom style full, without image flags</li><li><a href="mass_atom_clayff.html">mass_atom_clayff(atom,varargin)</a> % This function fetches the atom weight from the clayff and interface ff's</li><li><a href="mass_atom.html">mass_atom(atom)</a> % This function fetches the mass for each atomtype and put it into atom.mass</li><li><a href="median_atom.html">median_atom(atom)</a> %&nbsp;This function calculates the median position of the atom struct</li><li><a href="merge_atom.html">merge_atom(atom1,Box1,atom2,type,Atom_label,r)</a> % This function returns the atom2 struct with atoms in the atom2 struct with a distance r [1x1 or 1x2] away from the atoms in the atom1 struct. There is also a possibility to use a twin-range cutoff approach (suitable for OH2), by setting r(2) to a smaller value than r(1)</li><li><a href="molid_rotate.html">molid_rotate(atom,Box_dim,MolID,rotate_dim)</a> %&nbsp;This function rotate the atom randomly</li><li><a href="molid_translate.html">molid_translate(atom,trans_vec,MolID)</a> % This translates a certain molid</li><li><a href="neigh_atom.html">neigh_atom(atom,Box_dim,rmax,varargin)</a> % This function checks which neighbors each atom has and ouputs their info</li><li><a href="neighbor_func.html">neighbor_func(solute_index,XYZ_solute,XYZ_data,Box_dim,radius)</a> % This function scans xyz data and checks who is within a certain radius. It outputs neighbour index,</li><li><a href="new_neigh_atom.html">new_neigh_atom(atom,Box_dim,rmax,varargin)</a> % Not finished yet...</li><li><a href="neutralize_atom.html">neutralize_atom(atom)</a> % This function appends a 0 to all atomtype names and will also set the  charge (if the field charge exist) to zero (0).</li><li><a href="number_type.html">numer_type(atom,varargin)</a> % This function numbers the atom types, like H1, H2, H3...</li><li><a href="opls_go_atom.html">opls_go_atom(atom,Box_dim,rmin,rlarge)</a> % This function tries to smear out the charge at around -OH and epoxides in GO</li><li><a href="oplsaa_go_param.html">oplsaa_go_param(Atom_label,water_model)</a> % This custom function holds the extended oplsaa_aa ff for graphite oxide</li><li><a href="orto_atom.html">orto_atom(atom,Box_dim)</a> %&nbsp;This transforms a triclinic atom struct to an orthogonal atom struct. Box_dim must look like [lx ly lz 0 0 xy 0 xz yz]</li><li><a href="order_attributes.html">order_attributes(atom)</a> % This function order the struct attributes, or fields in a certain order.</li><li><a href="overwrite_atom.html">overwrite_atom(In_atom,atomtype,resname)</a> % This function overwrites the atom struct information with new information&nbsp;</li><li><a href="PATH2GMX.html">PATH2GMX()</a> % The Gromacs path on your computer</li><li><a href="PATH2VMD.html">PATH2VMD()</a> % The VMD path on your computer</li><li><a href="place_atom.html">place_atom(atom,position)</a> % This function places the atom struct according to the position vector called position, trying to use the COM of the molecule</li><li><a href="plot_density_atom.html">plot_density_atom(atom,Box_dim,varargin)</a> % This function draws the atom struct in 3D adjoined by some density profiles</li><li><a href="plot_atom.html">plot_atom(atom,Box_dim,varargin)</a> % This function draws the atom struct in 3D. Its very simplistic with no cool features</li><li><a href="poly_atom.html">poly_atom(atom,Box_dim,varargin)</a> % This function tries to plot pretty polyhedras, similar to the show_atom function</li><li><a href="position_molid.html">position_molid(atom,position_vec,MolID)</a> %&nbsp;This function movies a molid (COM)&gt; % to a certain position</li><li><a href="protonate_atom.html">protonate_atom(atom,Box_dim,varargin)</a> % This function protonates the sites in the atom struct given by the index vector ind by adding a H's to a new H atom struct.</li><li><a href="radius_atom.html">radius_atom(atom,ffname,watermodel)</a> % This function fetches the ion radius from clayff or interface or interface2015 ff's and</li><li><a href="radius_ion.html">radius_ion(Atom_label)</a> % This function fetches the ionic radius, originally taken from the link below</li><li><a href="radius_vdw.html">radius_vdw(Atom_label)</a> % This function fetches the rdw radius, originally taken from below from 'A cartography of the van der Waals territories' Santiago Alvarez doi:10.1039/c3dt50599e</li><li><a href="rdf_atom.html">rdf_atom(atom,Box_dim,varargin)</a> % This function calculates the radial distributtion function and the coordination number. Can also do Gaussion smoothing.</li><li><a href="reduced_mass.html">reduced_mass(Atom_label1,varargin)</a> % This function calculates the reduced mass.</li><li><a href="remove_H2O.html">remove_H2O(atom,Box_dim)</a> % This function removes H2O molecules, by searching for all water-like bonded H,O atoms within rmin, which optionally can be set manually.</li><li><a href="remove_molid.html">remove_molid(atom,MolID)</a> %&nbsp; remove_molid.m - This removes residue with molid MolID = [1 2 3 .....]</li><li><a href="remove_occypancy_atom.html">remove_occypancy_atom(atom)</a> % This function removes all succeding particles in the atom struct that has identical coordinates to a preceding particle</li><li><a href="remove_residues.html">remove_residues(atom,resnames,lo,hi,dim)</a> %&nbsp;This function section is used to remove residues in the simulation box between limits lo and hi</li><li><a href="remove_resname.html">remove_resname(atom,resnames)</a> %&nbsp;This function removes residue with molid MolID, resnames = {'SOL' 'Protein'}</li><li><a href="remove_SOL.html">remove_SOL(atom,atomname,lo,hi,dim)</a> %&nbsp; This section is used to remove residues in the simulation box between limits lo and hi</li><li><a href="remove_type.html">remove_type(atom,typescell)</a> %&nbsp;This function removes atomtypes with types as in typescell = {'OW' 'HW1' 'HW2'}</li><li><a href="rename_type.html">rename_type(atom,atomtype,new_atomtype,varargin)</a> %&nbsp;This function renames atoms in the atom</li><li><a href="reorder_atom_gro.html">reorder_atom_gro(atom,atomlist,Box_dim,filename_out)</a> %&nbsp;This function reorders the atoms in a .gro file</li><li><a href="reorder_atom.html">reorder_atom(atom,atomlist)</a> %&nbsp;This function reorders the atoms in the atom struct</li><li><a href="replace_atom.html">replace_atom(new_atom,prev_atom,molid_index)</a> % This function replaces molid's in an atom struct with a new (single molid) atom struct by placing the latters COM in the formers place</li><li><a href="replicate_atom.html">replicate_atom(atom,Box_dim,replicate)</a> %&nbsp; replicate_atom.m This replicates the atom struct and the orthogonal box dimensions</li><li><a href="resname_atom.html">resname_atom(atom)</a> % This function tries to guess the resname of all atom types</li><li><a href="rotate_atom.html">rotate_atom(atom,Box_dim,alfa,beta,gamma)</a> %&nbsp;This function rotate the atom randomly</li><li><a href="round_atom.html">round_atom(atom,Box_dim,varargin)</a> % This function rounds the coordinates in the atom struct</li><li><a href="scale_atom.html">scale_atom(atom,scale_vec,Box_dim,Resname)</a> %&nbsp;This function scales the coordinates in the atom struct</li><li><a href="show_density_atom.html">show_density_atom(atom,Box_dim,varargin)</a> % This function draws the atom struct in 3D adjoined by some density profiles</li><li><a href="show_atom.html">show_atom(atom,varargin)</a> % This function draws the atom struct in 3D. Its a bit fancier that plot_atom()</li><li><a href="show_arrow.html">show_arrow(p1,p2,varargin)</a> % * plot a 3D arrow as patch object (cylinder+cone). This function was adapted from mArrow3.m</li><li><a href="show_axis.html">show_axis(varargin)</a> % * This function draws the axis in a plot</li><li><a href="show_box.html">show_box(Box_dim)</a> % * This function draws the simulation box</li><li><a href="show_miller.html">show_miller(Box_dim)</a> % * This function draws the hkl Miller planes of the Box_dim/Cell variables</li><li><a href="sigma_vdw.html">sigma_vdw(Atom_label)</a> % This function fetches the sigma radius parameter, originally taken from the link below from 'A cartography of the van der Waals territories' Santiago Alvarez doi:10.1039/c3dt50599e</li><li><a href="slice_atom.html">slice_atom(atom,limits,invert)</a> %&nbsp;This function checks if the coordinates for each time record in XYZ_data is within the specified limits, and if not sets the x,y,z to nan,nan,nan.</li><li><a href="slice_molid.html">slice_molid(atom,limits,invert)</a> %&nbsp;This function checks if the coordinates is within the specified limits, and if not sets the x,y,z to nan,nan,nan.</li><li><a href="slice_triclinic_atom.html">slice_triclinic_atom(atom,limits,invert)</a> % This function slices the atoms into the triclinic box.</li><li><a href="solvate_atom.html">solvate_atom(limits,density,r,maxsol,solute_atom,varargin)</a> % This function generates a certain region defined by <a href="limits">limits</a> with a solvent structure of density <a href="density">density</a></li><li><a href="sort_atom.html">sort_atom(atom)</a> %&nbsp;sort_atom.m - This section orders to atoms with respect to z</li><li><a href="sort_molid.html">sort_molid(Molid)</a> % This function sorts the molecular indexes in an ascending order</li><li><a href="sphere_atom.html">sphere_atom(atom,Box_dim,radius)</a> % * This function slices a spherical particle (like a colloid) of the atom struct</li><li><a href="spiral_atom.html">spiral_atomspiral_atom(atom,Box_dim,[0 0 90])</a> % This function spiral the atom randomly or by the angles given by the spiral vector</li><li><a href="spc2tip4p.html">spc2tip4p(filename)</a> % This function converts a .gro or .pdb file with spc water to some tip4p water</li><li><a href="spc2tip5p.html">spc2tip5p(filename)</a> % This function converts a .gro or .pdb file with spc water to some tip5p water</li><li><a href="spce2tip4p.html">spce2tip4p(filename)</a> % This function converts a .gro or .pdb file with spc water to some tip4p water</li><li><a href="substitute_atom.html">substitute_atom(atom,Box_dim,NumOctSubst,O1,O2,minO2O2_dist,varargin)</a> % This scripts performs isomorphous substitution, by replacing some O1-&gt;O2 atomtypes and optionally T1-&gt;T2 atomtypes</li><li><a href="tip3p2tip4p.html">tip3p2tip4p(filename)</a> %&nbsp;This function converts a .gro file with spc water to some tip4p water</li><li><a href="tile_atom.html">tile_atom(atom,scale_vec,Box_dim,Resname)</a> %&nbsp;This function tiles the atom struct similar to replicate atom, but with a translation along some direction. Triclinic version untestd but might work..</li><li><a href="translate_atom.html">translate_atom(atom,trans_vec,Resname)</a> % translate_atom.m - This translates the resname by a vector</li><li><a href="translate_molid.html">translate_molid(atom,trans_vec,molid)</a> %&nbsp; translate_molid.m - This translates the molid by a vector</li><li><a href="triclinic_atom.html">triclinic_atom(atom,Box_dim,angleparam,angletype)</a> %&nbsp; triclinic_atom.m - This transforms an orthogonal atom struct to a triclinic with the angles alfa, beta, gamma or tilt factors xy, xz, yz</li><li><a href="tube_atom.html">tube_atom(atom,scale_vec,Box_dim,Resname)</a> %&nbsp;* This quirky function can be used to create a nano-tube or nano-roll of the  coordinates from an atom struct. It works best if the the input atom struct  consists of one centered unit cell (to keep the number of atoms down).</li><li><a href="tweak_charge_atom.html">tweak_charge_atom(atom)</a> % This function tries to tweak the charge of the atom struct in case of rounding errors</li><li><a href="unwrap_atom.html">unwrap_atom(atom,Box_dim,dim)</a> %&nbsp;This function unwraps the atom struct along the dimension dim</li><li><a href="update_atom.html">update_atom(atom)</a> %&nbsp;This function updates the molid index and the atoms index in the atom struct</li><li><a href="vmd.html">vmd(atom,Box_dim)</a> %&nbsp;This function plots the atom struct</li><li><a href="wrap_atom.html">wrap_atom(atom,Box_dim)</a> % This wraps the atoms into the orthogonal box</li><li><a href="Wrap_Coord_func.html">Wrap_Coord_func(XYZ_data,Box_dim)</a> % This is an old function that wraps atoms 'sticking out' back into the box</li><li><a href="wrap_molid.html">wrap_molid(atom,Box_dim)</a> % This function wraps the atom struct into the box</li><li><a href="write_atom_all.html">write_atom_all(atom,Box_dim,filename_out,varargin)</a> % This function tries to write various files for you. Works best for systems designed for Clayff...</li><li><a href="write_atom_cif.html">write_atom_cif(atom,Box_dim,filename_out)</a> %&nbsp;This function writes a basic .cif file from the atom struct</li><li><a href="write_atom_gro.html">write_atom_gro(atom,Box_dim,filename_out)</a> % This function writes a gro file. Does it also write velocities?</li><li><a href="write_atom_itp.html">write_atom_itp(atom,Box_dim,filename_out,varargin)</a> % This script creates and prints a gromacs .itp file. Works best for clayff or interface ff with spc, spce or tip3p</li><li><a href="write_atom_lmp.html">write_atom_lmp(atom,Box_dim,filename_out,varargin)</a> % This script creates and prints a lammps data file (.lj). Works best for Clayff systems</li><li><a href="write_atom_mol2.html">write_atom_mol2(atom,Bond_index,Box_dim,filename_out)</a> %&nbsp;This function writes a .mol2 file from the atom struct</li><li><a href="write_atom_multiple_gro.html">write_atom_multiple_gro(atom,traj,filename_out)</a> % % * This function writes a .gro trajectory I think this function works...</li><li><a href="write_atom_oplsaa_go_itp.html">write_atom_oplsaa_go_itp(atom,Box_dim,filename_out,varargin)</a> % This custom made script creates and prints a gromacs .itp file for&nbsp;</li><li><a href="write_atom_pdb.html">write_atom_pdb(atom,Box_dim,filename_out)</a> %&nbsp;This function writes an .pdb file from the atom struct using Gromacs</li><li><a href="write_atom_pqr.html">write_atom_pqr(atom,Box_dim,filename_out,varargin)</a> % This function writes an .pqr file from the atom struct</li><li><a href="write_atom_psf.html">write_atom_psf(atom,Box_dim,filename_out,varargin)</a> % This function writes an .psf file from the atom struct</li><li><a href="write_atom_xyz.html">write_atom_xyz(atom,Box_dim,filename_out)</a> %&nbsp;This function writes an XYZ file from the atom struct</li><li><a href="write_atom.html">write_atom(atom,Box_dim,filename_out,varargin)</a> % This function writes the below listed file types depending on the filename and passed variables, ie either a .gro|.pdb|.xyz|.itp and so on</li><li><a href="write_gro_traj.html">write_gro_traj(atom,traj,Box_dim,filename_out)</a> %&nbsp;This function writes a .gro trajectory&nbsp;</li><li><a href="write_pdb_traj.html">write_pdb_traj(atom,traj,Box_dim,filename_out)</a> %&nbsp;This function writes a .pdb trajectory&nbsp;</li><li><a href="write_xyz_traj.html">write_xyz_traj(atom,traj,Box_dim,filename_out)</a> %&nbsp;This function writes a .xyz trajectory&nbsp;</li><li><a href="xrd_atom.html">xrd_atom(varargin)</a> % This function calculates theoretical XRD patterns from a .pdb|.gro file or from an atom struct and Box_dim.</li><li><a href="xyz2atom.html">xyz2atom(XYZ_labels,XYZ_data,Box_dim,resname,in_atom)</a> % This function can be used to add XYZ data (like from a .xyz structure file)to the atom struct format</li></ol></div><h2 id="4">Version</h2><p>2.11</p><h2 id="5">Contact</h2><p>Please report problems/bugs to <a href="mailto:michael.holmboe@umu.se">michael.holmboe@umu.se</a></p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Complete list of all atom functions
%
%% Version
% 2.11
%
%% Contact
% Please report problems/bugs to michael.holmboe@umu.se
%

%% All functions
% # <add2atom.html add2atom(XYZ_labels,XYZ_data,varargin)> % This function appends so-called XYZ atomtype labels and XYZ data to an existing atom struct
% # <analyze_atom.html analyze_atom(atom,Box_dim)> % This function fetches various preperties of the atoms in the atom struct, using for instance the bond valence method and for instance the radii originally taken from below	Revised effective ionic radii and systematic studies of interatomic distances in halides and chalcogenides. R. D. Shannon Acta Cryst. (1976) A32, 751-767.
% # <atom2make_ndx_bonded.html atom2make_ndx_bonded(filename,groupname,atomtypes)> % This function can help you print one custom gromacs .ndx group,based on the atomtypes names.
% # <atom2make_ndx.html atom2make_ndx(filename,groupname,atomtypes,molid)> % This little script can be used to write custom made Gromacs index files
% # <atom2mk_angndx atom2mk_angndx(filename,groupname,atomtypes)> % This function can help you print one custom gromacs angle.ndx group, based on the atomtypes names
% # <atomic_scattering_factors.html atomic_scattering_factors(Atom_label,lambda,twotheta,DW)> % This function retrieves the atomic scattering factor vs 2theta using the 11 coeff parameters from Waasmaier Kirfel, 1995
% # <ave_atom.html ave_atom(atom)> % This function calculates the mean of the atom coordinates
% # <bend_atom.html bend_atom(atom,Box_dim,Radii)> % This simple function tries to bend an atom struct
% # <bond_atom.html bond_atom(atom,Box_dim,max_long_dist)> % This function tries to assign all bonds to a Bond_matrix and a Bond_index variable
% # <bond_angle_atom.html bond_angle_atom(atom,Box_dim,max_short_dist,max_long_dist,varargin)> % This function tries to find all bonds and angles of the atom struct 'more' is an optional varargin argument
% # <bond_angle_type.html bond_angle_type(atom1,atom2,Box_dim,rmin,rmax,angle_limit,varargin)> % This tries to find all bonds and angles of the atom types
% # <bond_angle_dihedral_atom.html bond_angle_dihedral_atom(atom,Box_dim,varargin)> % This function tries to find all bonds, angles and dihedrals of the atom struct. Rmaxshort and Rmaxlong as well as 'more' is an optional varargin argument
% # <bond_valence_atom.html bond_valence_atom(atom,Box_dim,varargin)> % This function tries to calculate the bond valence values according to the bond valence method
% # <bond_valence_data.html bond_valence_data(ion1,ion2,R,varargin)> % This function fetches the data and matches it to the passed atom types used to calculate the bond valence values according to http://www.iucr.org/resources/data/datasets/bond-valence-parameters
% # <cat_atom.html cat_atom.m> % This is a special script (and not a function) that imports and appends atom structs into a .gro trajectory file, useful to make a trajectory with varying number of particles
% # <cell_list_dist_matrix_atom.html cell_list_dist_matrix_atom(atom,Box_dim,varargin)> % This function calculates the distance matrix from the atom struct, using a cell list algorithm adapted from the Matlab MDtoolbox by Yasuhiro Matsunaga
% # <Box_dim2Cell.html Box_dim2Cell(Box_dim)> % * This function transforms the 1x3 or the 1x9 Box_dim variable to the 1x6 Cell variable
% # <Cell2Box_dim.html Cell2Box_dim(Cell)> % ** This function transforms the 1x6 Cell variable containing the a, b, c cell values and  the alfa, beta, gamma angle values as used in a typical .pdb file, into a 1x3 or the 1x9  Box_dim variable  
% # <center_atom.html center_atom(atom,Box_dim,resname,dim)> % This function centers the atom with respect to the resname molecule
% # <charge_atom.html charge_atom(atom,Box_dim,ffname,watermodel,varargin)> % This function tries to charge the atom accorind to clayff or interface ff
% # <charge_clayff_2004_atom.html charge_clayff_2004_atom(atom,Box_dim,varargin)> % Sets the charge for the original Clayff atomtypes for the original Clayff ff from the Cygan et al., 2004 paper
% # <charge_clayff_atom.html charge_clayff_atom(atom,Box_dim,varargin)> % Sets the charge for Clayff atomtypes 
% # <charge_interface_atom.html charge_interface_atom(atom,Box_dim,varargin)> % Sets the charge for Interface atomtypes 
% # <charge_interface15_atom.html charge_interface15_atom(atom,Box_dim,varargin)> % Sets the charge for Interface 1.5 atomtypes
% # <charge_opls_go_atom.html charge_opls_go_atom(atom,Box_dim,varargin)> % Sets the charge for some specific OPLS atomtypes
% # <check_clayff_2004_charge.html check_clayff_2004_charge(atom)> % check_clayff_2004_charge.m - This checks the charge of the original Clayff atomtypes by Mholmboe
% # <check_clayff_charge.html check_clayff_charge(atom)> % check_clayff_charge.m - This checks the charge of the Clayff atomtypes by Mholmboe
% # <check_clayff_H2Odens.html check_clayff_H2Odens(atom,Box_dim)> % Check the approx. water density for a clayff system
% # <check_H2Odens.html check_H2Odens(atom,Box_dim)> % Computes the water density
% # <check_interface_charge.html check_interface_charge(atom)> %  This checks the charge of the INTERFACE atomtypes by Mholmboe
% # <check_interface15_charge.html check_interface15_charge(atom)> %  This checks the charge of the INTERFACE 1.5 atomtypes by Mholmboe
% # <cn_atom.html cn_atom(atom,Box_dim)> % This function tries to extract the coordination number of all the atom struct indexes and store it in the field [atom.cn]. 
% # <clayff_2004_atom.html clayff_2004_atom(atom,Box_dim,varargin)> % Assigns the original Clayff atom types by Cygan et al., 2004. Can also 'heal' edges 
% # <clayff_2004_param.html clayff_2004_param(Atom_label,varargin)> % Holds the ion and the original Clayff atomtype parameters
% # <clayff_atom.html clayff_atom(atom,Box_dim,varargin)> % Assigns the Clayff atom types by MHolmboe. Can also 'heal' edges 
% # <clayff_param.html clayff_param(Atom_label,varargin)> % Holds the ion and Clayff atomtype parameters
% # <clayff210_atom.html clayffmod_atom(atom,Box_dim,varargin)> % Assigns the modififed Clayff atom types. Can also 'heal' edges 
% # <clayff211_atom.html clayffmod_atom(atom,Box_dim,varargin)> % New faster version. Assigns the modififed Clayff atom types. Can also 'heal' edges 
% # <closest_atom.html closest_atom(atom1,atom2,Box_dim)> % This function returns the atom1 struct with the nMolId's in atom1 closest to the atom2 struct.
% # <COM_atom.html COM_atom(atom,MolID)> % This function calculates the COM for certain elements
% # <COM_func.html COM_func(MolID,XYZ_data,Atom_label,XYZ_labels,Box_dim)> % This calculates the center of mass for water. Slow due to pbc...
% # <COM_molid.html COM_molid(atom,MolID)> % This function calculates the COM for certain elements
% # <COM_SOL.html COM_SOL(MolID,XYZ_data,Atom_label,XYZ_labels,Box_dim)> % Computes the COM of SPC water?
% # <composition_atom.html composition_atom(atom)> % This function looks at the composition of the atom struct
% # <concatenate_atom.html concatenate_atom(atom_1,atom_2)> % This function concatenats atom sections.
% # <condense_atom.html condense_atom(atom,Box_dim,s)> % This function tries to minimize the box size and remove gaps between molids?
% # <CONECT_atom.html CONECT_atom(atom,Box_dim,short_r,long_r)> % This prints conect records for pdb files
% # <copy_atom.html copy_atom(atom,atomtype,new_atomtype,new_resname,trans_vec,varargin)> % This function copies and translates atoms in the atom struct
% # <copy_type.html copy_type(atom,atomtype,new_atomtype,new_resname,trans_vec,varargin)> % This function copies and translates types in the atom struct
% # <create_atom.html create_atom(type,resname,limits,nmax,varargin)> % Creates new atoms, good for adding ions to a system. Creates atoms within a certain region defined by <limits>
% # <create_grid_atom.html create_grid_atom(atom_label,nM,limits,dim,varargin)> % This old function puts ions on a grid plane and adds it to an atom struct
% # <density_atom.html density_atom(atom,Box_dim)> % This function calculates concentration and electron density profiles. If the atom struct contains the field charge. the charge density, electric field and electrostatic potential is also calculated. 
% # <dipoles_atom.html dipoles_atom(Elements,Box_dim)> % This function calculates the dipole vector of water. Similar to the COM_func
% # <dist_matrix_atom.html dist_matrix_atom(atom,Box_dim)> % This calculates the distance matrix from the atom struct
% # <draw_box_atom.html draw_box_atom(Box_dim,LineColor,LineThickness)> % Draws a box
% # <duplicate_atom.html duplicate_atom(atom,molID)> % This function duplicates residue with molid MolID
% # <element_atom.html element_atom(atom,varargin)>  % Converts atomtypes to element types. This function replaces the atomtypes names with the element names
% # <element_color.html element_color(Atom_label)> % This function assigns a certain color to each element. Estethic improvements are welcome...
% # <find_bonded_atom.html find_bonded_atom(atom,bond_matrix,label1,label2)> % This function does a cross check of the bond matrix
% # <find_pair_atom.html find_pair_atom(atom,bond_matrix,Atom_label1,Atom_label2)> % This function does a cross check of the bond matrix
% # <fit2lattice_atom.html fit2lattice_atom(atom_model,atom_ref,Box_dim_ref)> % This is a special function imports a model structure of a single molecule like PO43- and tries to fit it into a crystal lattice possibly holding multiple such sites.
% # <frac2atom.html frac2atom(atom,Box_dim,angleparam,angletype)> % This function transforms fractional coordinates to cartesian
% # <frame2atom.html frame2atom(atom,traj,frame,Box_dim,varargin)> % This function extracts a frame to the trajectory matrix
% # <fuse_atom.html fuse_atom(atom,Box_dim,varargin)> % This function tries to fuse all sites within a certain cutoff rmax, typically 0.85 Å
% # <G2_atom.html G2_atom(atom,Box_dim)> % This function calculates the continuous G2 factor from the cos and sin terms and also saves a struct variable for G2_calc_func(). You might wnat to edit the atomtype names below to fit your needs...
% # <gmx_make_ndx.html gmx_make_ndx(groupname,ind)> % This function helps you print custom gromacs .ndx files
% # <gmx_mk_angndx.html gmx_mk_angndx(groupname,ind)> % This function helps you print custom gromacs angle .ndx files
% # <grid2atom.html grid2atom(atom_label,nM,limits,dim,varargin)> %  grid2atom.m - This puts particles such as ions on a 2D grid (i.e. a plane)> % and adds it to an atom struct
% # <heal_atom.html heal_atom(atom,Box_dim,ind,varargin)> % This function heals sites in the atom struct given by the index vector ind, by adding a certain atomtype to a new atom struct called healed_atom. It does so by placing the new atom type opposite to the mean position of all neighbours within rcut [Å] of the healed site.
% # <hist_atom.html hist_atom(atom,s)> % This function is used to calculate density profiles in the X|Y|Z-direction
% # <histz_atom.html histz_atom(atom,s)> % This function is used to calculate density profiles in the Z-direction
% # <import_atom_car.html import_atom_car(filename,varargin)> % This function imports .car files from Hendrik Heinz INTERFACE ff distribution, and then tries to write out a Gromacs molecular topology file (.itp) and a new .pdb file
% # <import_atom_gro.html import_atom_gro(filename)> % This function imports .gro files into the atom struct
% # <import_atom_multiple_gro.html import_atom_multiple_gro(filename,nFrames)> % This function import multiple .gro files
% # <import_atom_pdb.html import_atom_pdb(filename)> % This function imports .pdb files into the atom struct
% # <import_atom_xyz.html import_atom_xyz(filename)> % This imports an .xyz file into the atom struct
% # <import_atom.html import_atom(filename)> % import_atom.m - This imports a .xyz/.gro/.pdb file and puts the data in a structure variable called atom
% # <import_gro_traj.html import_gro_traj(filename,varargin)> % This function imports an strcture and an .gro trajectory file
% # <import_mc_pdb_traj.html import_mc_pdb_traj(filename,varargin)> % This function imports an structure and an .pdb trajectory file, and can handle changing number of particles
% # <import_pdb_traj.html import_pdb_traj(filename,varargin)> % This function imports an strcture and an .pdb trajectory file.
% # <import_traj.html import_traj(filenameconf,filenametraj)> % This function imports an strcture and an dcd, trr, xtc, xyz or gro  trajectory file.
% # <import_trr.html import_trr(filenameconf,filenametraj)> % This function imports an structure and an trr  trajectory file
% # <import_trrv2.html import_trrv2(filenameconf,filenametraj)> % This function imports an structure and an trr  trajectory file
% # <import_xtc.html import_xtc(filenameconf,filenamextc)> % import_atom_xtc.m - This imports a structure file and a xtc file
% # <import_xtcv2.html import_xtcv2(filenameconf,filenamextc)> % import_atom_xtc.m - This imports a structure file and a xtc file
% # <import_xvg.html import_xvg(filename)> % This function imports a Gromacs .xvg file
% # <import_xyz_traj.html import_xyz_traj(filenametraj)> % import_xyz_traj.m - This imports an strcture and an .xyz trajectory file.
% # <import_xyz.html import_xyz(filename)> % This function imports an .xyz file. Atom types should be made of letters, not numbers... Try the import_atom_xyz function instead...
% # <insert_atom.html insert_atom(atom_in,limits,rotate,r,maxsol,solute_atom,varargin)> % - This inserts a molecule from a structure file into a region defined by <limits> with a atom (molecule)> % structure
% # <interface_atom.html interface_atom(atom,Box_dim,varargin)> % This function tries to assign all atoms according to the interface atom types (with modified atom names by MHolmboe), with some modifications for edges...
% # <interface_param.html interface_param(Atom_label,water_model)> %  This holds the extended INTERFACE ff parameters
% # <interface15_atom.html interface15_atom(atom,Box_dim,varargin)> % This function tries to assign all atoms according to the interface1.5 atom types (with modified atom names by MHolmboe), with some modifications for edges...
% # <interface15_param.html interface15_param(Atom_label,water_model)> %  This holds the extended INTERFACE1.5 ff parameters
% # <ionize_atom.html ionize_atom(type,resname,limits,nmax,varargin)> % This function adds ions within a certain region defined by <limits> or close to a surface in an exponential fashion
% # <keep_atom.html keep_atom(atom,resname)> % keep_atom.m - This removes all but resname
% # <keep_resname.html keep_resname(atom,resnames)> % keep_resname.m - This removes all but the resnames
% # <lmp_atom_style_full_func.html lmp_atom_style_full_func(fid,Atom_label,Charge,XYZ_labels,XYZ_data)> % This creates and prints the Atoms section properties in the LAMMPS data file .lj file according to atom style full, without image flags
% # <mass_atom_clayff.html mass_atom_clayff(atom,varargin)> % This function fetches the atom weight from the clayff and interface ff's
% # <mass_atom.html mass_atom(atom)> % This function fetches the mass for each atomtype and put it into atom.mass
% # <median_atom.html median_atom(atom)> % This function calculates the median position of the atom struct
% # <merge_atom.html merge_atom(atom1,Box1,atom2,type,Atom_label,r)> % This function returns the atom2 struct with atoms in the atom2 struct with a distance r [1x1 or 1x2] away from the atoms in the atom1 struct. There is also a possibility to use a twin-range cutoff approach (suitable for OH2), by setting r(2) to a smaller value than r(1)
% # <molid_rotate.html molid_rotate(atom,Box_dim,MolID,rotate_dim)> % This function rotate the atom randomly
% # <molid_translate.html molid_translate(atom,trans_vec,MolID)> % This translates a certain molid
% # <neigh_atom.html neigh_atom(atom,Box_dim,rmax,varargin)> % This function checks which neighbors each atom has and ouputs their info
% # <neighbor_func.html neighbor_func(solute_index,XYZ_solute,XYZ_data,Box_dim,radius)> % This function scans xyz data and checks who is within a certain radius. It outputs neighbour index,
% # <new_neigh_atom.html new_neigh_atom(atom,Box_dim,rmax,varargin)> % Not finished yet...
% # <neutralize_atom.html neutralize_atom(atom)> % This function appends a 0 to all atomtype names and will also set the  charge (if the field charge exist) to zero (0).
% # <number_type.html numer_type(atom,varargin)> % This function numbers the atom types, like H1, H2, H3...
% # <opls_go_atom.html opls_go_atom(atom,Box_dim,rmin,rlarge)> % This function tries to smear out the charge at around -OH and epoxides in GO
% # <oplsaa_go_param.html oplsaa_go_param(Atom_label,water_model)> % This custom function holds the extended oplsaa_aa ff for graphite oxide
% # <orto_atom.html orto_atom(atom,Box_dim)> % This transforms a triclinic atom struct to an orthogonal atom struct. Box_dim must look like [lx ly lz 0 0 xy 0 xz yz]
% # <order_attributes.html order_attributes(atom)> % This function order the struct attributes, or fields in a certain order.
% # <overwrite_atom.html overwrite_atom(In_atom,atomtype,resname)> % This function overwrites the atom struct information with new information 
% # <PATH2GMX.html PATH2GMX()> % The Gromacs path on your computer
% # <PATH2VMD.html PATH2VMD()> % The VMD path on your computer
% # <place_atom.html place_atom(atom,position)> % This function places the atom struct according to the position vector called position, trying to use the COM of the molecule
% # <plot_density_atom.html plot_density_atom(atom,Box_dim,varargin)> % This function draws the atom struct in 3D adjoined by some density profiles
% # <plot_atom.html plot_atom(atom,Box_dim,varargin)> % This function draws the atom struct in 3D. Its very simplistic with no cool features
% # <poly_atom.html poly_atom(atom,Box_dim,varargin)> % This function tries to plot pretty polyhedras, similar to the show_atom function
% # <position_molid.html position_molid(atom,position_vec,MolID)> % This function movies a molid (COM)> % to a certain position
% # <protonate_atom.html protonate_atom(atom,Box_dim,varargin)> % This function protonates the sites in the atom struct given by the index vector ind by adding a H's to a new H atom struct.
% # <radius_atom.html radius_atom(atom,ffname,watermodel)> % This function fetches the ion radius from clayff or interface or interface2015 ff's and
% # <radius_ion.html radius_ion(Atom_label)> % This function fetches the ionic radius, originally taken from the link below
% # <radius_vdw.html radius_vdw(Atom_label)> % This function fetches the rdw radius, originally taken from below from 'A cartography of the van der Waals territories' Santiago Alvarez doi:10.1039/c3dt50599e
% # <rdf_atom.html rdf_atom(atom,Box_dim,varargin)> % This function calculates the radial distributtion function and the coordination number. Can also do Gaussion smoothing.
% # <reduced_mass.html reduced_mass(Atom_label1,varargin)> % This function calculates the reduced mass.
% # <remove_H2O.html remove_H2O(atom,Box_dim)> % This function removes H2O molecules, by searching for all water-like bonded H,O atoms within rmin, which optionally can be set manually.
% # <remove_molid.html remove_molid(atom,MolID)> %  remove_molid.m - This removes residue with molid MolID = [1 2 3 .....]
% # <remove_occypancy_atom.html remove_occypancy_atom(atom)> % This function removes all succeding particles in the atom struct that has identical coordinates to a preceding particle
% # <remove_residues.html remove_residues(atom,resnames,lo,hi,dim)> % This function section is used to remove residues in the simulation box between limits lo and hi
% # <remove_resname.html remove_resname(atom,resnames)> % This function removes residue with molid MolID, resnames = {'SOL' 'Protein'}
% # <remove_SOL.html remove_SOL(atom,atomname,lo,hi,dim)> %  This section is used to remove residues in the simulation box between limits lo and hi
% # <remove_type.html remove_type(atom,typescell)> % This function removes atomtypes with types as in typescell = {'OW' 'HW1' 'HW2'}
% # <rename_type.html rename_type(atom,atomtype,new_atomtype,varargin)> % This function renames atoms in the atom
% # <reorder_atom_gro.html reorder_atom_gro(atom,atomlist,Box_dim,filename_out)> % This function reorders the atoms in a .gro file
% # <reorder_atom.html reorder_atom(atom,atomlist)> % This function reorders the atoms in the atom struct
% # <replace_atom.html replace_atom(new_atom,prev_atom,molid_index)> % This function replaces molid's in an atom struct with a new (single molid) atom struct by placing the latters COM in the formers place
% # <replicate_atom.html replicate_atom(atom,Box_dim,replicate)> %  replicate_atom.m This replicates the atom struct and the orthogonal box dimensions
% # <resname_atom.html resname_atom(atom)> % This function tries to guess the resname of all atom types
% # <rotate_atom.html rotate_atom(atom,Box_dim,alfa,beta,gamma)> % This function rotate the atom randomly
% # <round_atom.html round_atom(atom,Box_dim,varargin)> % This function rounds the coordinates in the atom struct
% # <scale_atom.html scale_atom(atom,scale_vec,Box_dim,Resname)> % This function scales the coordinates in the atom struct
% # <show_density_atom.html show_density_atom(atom,Box_dim,varargin)> % This function draws the atom struct in 3D adjoined by some density profiles
% # <show_atom.html show_atom(atom,varargin)> % This function draws the atom struct in 3D. Its a bit fancier that plot_atom()
% # <show_arrow.html show_arrow(p1,p2,varargin)> % * plot a 3D arrow as patch object (cylinder+cone). This function was adapted from mArrow3.m
% # <show_axis.html show_axis(varargin)> % * This function draws the axis in a plot
% # <show_box.html show_box(Box_dim)> % * This function draws the simulation box
% # <show_miller.html show_miller(Box_dim)> % * This function draws the hkl Miller planes of the Box_dim/Cell variables
% # <sigma_vdw.html sigma_vdw(Atom_label)> % This function fetches the sigma radius parameter, originally taken from the link below from 'A cartography of the van der Waals territories' Santiago Alvarez doi:10.1039/c3dt50599e
% # <slice_atom.html slice_atom(atom,limits,invert)> % This function checks if the coordinates for each time record in XYZ_data is within the specified limits, and if not sets the x,y,z to nan,nan,nan.
% # <slice_molid.html slice_molid(atom,limits,invert)> % This function checks if the coordinates is within the specified limits, and if not sets the x,y,z to nan,nan,nan.
% # <slice_triclinic_atom.html slice_triclinic_atom(atom,limits,invert)> % This function slices the atoms into the triclinic box.
% # <solvate_atom.html solvate_atom(limits,density,r,maxsol,solute_atom,varargin)> % This function generates a certain region defined by <limits> with a solvent structure of density <density>
% # <sort_atom.html sort_atom(atom)> % sort_atom.m - This section orders to atoms with respect to z
% # <sort_molid.html sort_molid(Molid)> % This function sorts the molecular indexes in an ascending order
% # <sphere_atom.html sphere_atom(atom,Box_dim,radius)> % * This function slices a spherical particle (like a colloid) of the atom struct
% # <spiral_atom.html spiral_atomspiral_atom(atom,Box_dim,[0 0 90])> % This function spiral the atom randomly or by the angles given by the spiral vector
% # <spc2tip4p.html spc2tip4p(filename)> % This function converts a .gro or .pdb file with spc water to some tip4p water
% # <spc2tip5p.html spc2tip5p(filename)> % This function converts a .gro or .pdb file with spc water to some tip5p water
% # <spce2tip4p.html spce2tip4p(filename)> % This function converts a .gro or .pdb file with spc water to some tip4p water
% # <substitute_atom.html substitute_atom(atom,Box_dim,NumOctSubst,O1,O2,minO2O2_dist,varargin)> % This scripts performs isomorphous substitution, by replacing some O1->O2 atomtypes and optionally T1->T2 atomtypes
% # <tip3p2tip4p.html tip3p2tip4p(filename)> % This function converts a .gro file with spc water to some tip4p water
% # <tile_atom.html tile_atom(atom,scale_vec,Box_dim,Resname)> % This function tiles the atom struct similar to replicate atom, but with a translation along some direction. Triclinic version untestd but might work..
% # <translate_atom.html translate_atom(atom,trans_vec,Resname)> % translate_atom.m - This translates the resname by a vector
% # <translate_molid.html translate_molid(atom,trans_vec,molid)> %  translate_molid.m - This translates the molid by a vector
% # <triclinic_atom.html triclinic_atom(atom,Box_dim,angleparam,angletype)> %  triclinic_atom.m - This transforms an orthogonal atom struct to a triclinic with the angles alfa, beta, gamma or tilt factors xy, xz, yz
% # <tube_atom.html tube_atom(atom,scale_vec,Box_dim,Resname)> % * This quirky function can be used to create a nano-tube or nano-roll of the  coordinates from an atom struct. It works best if the the input atom struct  consists of one centered unit cell (to keep the number of atoms down).
% # <tweak_charge_atom.html tweak_charge_atom(atom)> % This function tries to tweak the charge of the atom struct in case of rounding errors
% # <unwrap_atom.html unwrap_atom(atom,Box_dim,dim)> % This function unwraps the atom struct along the dimension dim
% # <update_atom.html update_atom(atom)> % This function updates the molid index and the atoms index in the atom struct
% # <vmd.html vmd(atom,Box_dim)> % This function plots the atom struct
% # <wrap_atom.html wrap_atom(atom,Box_dim)> % This wraps the atoms into the orthogonal box
% # <Wrap_Coord_func.html Wrap_Coord_func(XYZ_data,Box_dim)> % This is an old function that wraps atoms 'sticking out' back into the box
% # <wrap_molid.html wrap_molid(atom,Box_dim)> % This function wraps the atom struct into the box
% # <write_atom_all.html write_atom_all(atom,Box_dim,filename_out,varargin)> % This function tries to write various files for you. Works best for systems designed for Clayff...
% # <write_atom_cif.html write_atom_cif(atom,Box_dim,filename_out)> % This function writes a basic .cif file from the atom struct
% # <write_atom_gro.html write_atom_gro(atom,Box_dim,filename_out)> % This function writes a gro file. Does it also write velocities?
% # <write_atom_itp.html write_atom_itp(atom,Box_dim,filename_out,varargin)> % This script creates and prints a gromacs .itp file. Works best for clayff or interface ff with spc, spce or tip3p
% # <write_atom_lmp.html write_atom_lmp(atom,Box_dim,filename_out,varargin)> % This script creates and prints a lammps data file (.lj). Works best for Clayff systems
% # <write_atom_mol2.html write_atom_mol2(atom,Bond_index,Box_dim,filename_out)> % This function writes a .mol2 file from the atom struct
% # <write_atom_multiple_gro.html write_atom_multiple_gro(atom,traj,filename_out)> % % * This function writes a .gro trajectory I think this function works...
% # <write_atom_oplsaa_go_itp.html write_atom_oplsaa_go_itp(atom,Box_dim,filename_out,varargin)> % This custom made script creates and prints a gromacs .itp file for 
% # <write_atom_pdb.html write_atom_pdb(atom,Box_dim,filename_out)> % This function writes an .pdb file from the atom struct using Gromacs
% # <write_atom_pqr.html write_atom_pqr(atom,Box_dim,filename_out,varargin)> % This function writes an .pqr file from the atom struct
% # <write_atom_psf.html write_atom_psf(atom,Box_dim,filename_out,varargin)> % This function writes an .psf file from the atom struct
% # <write_atom_xyz.html write_atom_xyz(atom,Box_dim,filename_out)> % This function writes an XYZ file from the atom struct
% # <write_atom.html write_atom(atom,Box_dim,filename_out,varargin)> % This function writes the below listed file types depending on the filename and passed variables, ie either a .gro|.pdb|.xyz|.itp and so on
% # <write_gro_traj.html write_gro_traj(atom,traj,Box_dim,filename_out)> % This function writes a .gro trajectory 
% # <write_pdb_traj.html write_pdb_traj(atom,traj,Box_dim,filename_out)> % This function writes a .pdb trajectory 
% # <write_xyz_traj.html write_xyz_traj(atom,traj,Box_dim,filename_out)> % This function writes a .xyz trajectory 
% # <xrd_atom.html xrd_atom(varargin)> % This function calculates theoretical XRD patterns from a .pdb|.gro file or from an atom struct and Box_dim.
% # <xyz2atom.html xyz2atom(XYZ_labels,XYZ_data,Box_dim,resname,in_atom)> % This function can be used to add XYZ data (like from a .xyz structure file)to the atom struct format
%
%% Version
% 2.11
%
%% Contact
% Please report problems/bugs to michael.holmboe@umu.se
##### SOURCE END #####
--></body></html>